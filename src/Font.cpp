// GLFT code. I'm going to be rewriting this file entirely. -shake

#include <GL/glfw3.h>
#include "Font.h"
#include <cstring>

// static members
FT_Library FTLibraryContainer::m_library;
FTLibraryContainer Font::m_library;

// FTLibraryContainer implementation //
FTLibraryContainer::FTLibraryContainer()
{
	if (FT_Init_FreeType(&m_library))
		throw std::runtime_error("Could not initialize FreeType2 library.");
}

FTLibraryContainer::~FTLibraryContainer()
{
	FT_Done_FreeType(m_library);
}

FT_Library& FTLibraryContainer::getLibrary()
{
	return m_library;
}

// Font implementation //

Font::Font() :
	texID_(0), listBase_(0),	// initalize GL variables to zero
	widths_(NUM_CHARS),		 // make room for 96 widths
	height_(0), m_X(0), m_Y(0)
{ }

Font::~Font()
{
	release();
}

void Font::Load(const std::string& filename, unsigned int size)
{
	const size_t MARGIN = 3;

	// release the font if it already exists
	release();

	// Step 1: Open the font using FreeType
	FT_Face face;

	if(FT_New_Face(m_library.getLibrary(), filename.c_str(), 0, &face) != 0)
		throw std::runtime_error("Could not load font file.");

	// Abort if this is not a scalable font.
	if(!(face->face_flags & FT_FACE_FLAG_SCALABLE) ||
		!(face->face_flags & FT_FACE_FLAG_HORIZONTAL))
		throw std::runtime_error("Invalid font: Error setting font size.");

	// Set the font size
	FT_Set_Pixel_Sizes(face, size, 0);

	// Step 2: Find maxAscent/Descent to calculate imageHeight
	size_t imageHeight = 0;
	size_t imageWidth = 256;
	int maxDescent = 0;
	int maxAscent = 0;
	size_t lineSpace = imageWidth - MARGIN;
	size_t lines = 1;
	size_t charIndex;

	for(unsigned int ch = 0; ch < NUM_CHARS; ++ch)
	{
		// Look up the character in the font file.
		charIndex = FT_Get_Char_Index(face, ch+SPACE);

		// Render the current glyph.
		FT_Load_Glyph(face, charIndex, FT_LOAD_RENDER);

		widths_[ch] = (face->glyph->metrics.horiAdvance >> 6) + MARGIN;
		// If the line is full go to the next line
		if(widths_[ch] > lineSpace)
		{
			lineSpace = imageWidth - MARGIN;
			++lines;
		}
		lineSpace -= widths_[ch];

		maxAscent = std::max(face->glyph->bitmap_top, maxAscent);
		maxDescent = std::max(face->glyph->bitmap.rows -
								face->glyph->bitmap_top, maxDescent);
	}

	height_ = maxAscent + maxDescent;   // calculate height_ for text

	// Compute how high the texture has to be.
	size_t neededHeight = (maxAscent + maxDescent + MARGIN) * lines + MARGIN;
	// Get the first power of two in which it will fit
	imageHeight = 16;
	while(imageHeight < neededHeight)
		imageHeight <<= 1;

	// Step 3: Generation of the actual texture

	// create and zero the memory
	unsigned char* image = new unsigned char[imageHeight * imageWidth];
	memset(image, 0, imageHeight * imageWidth);

	// These are the position at which to draw the next glyph
	size_t x = MARGIN;
	size_t y = MARGIN + maxAscent;
	float texX1, texX2, texY1, texY2;   // used for display list

	listBase_ = glGenLists(NUM_CHARS);  // generate the lists for filling

	// Drawing loop
	for(unsigned int ch = 0; ch < NUM_CHARS; ++ch)
	{
		size_t charIndex = FT_Get_Char_Index(face, ch+SPACE);

		// Render the glyph
		FT_Load_Glyph(face, charIndex, FT_LOAD_DEFAULT);
		FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL);

		// See whether the character fits on the current line
		if(widths_[ch] > imageWidth - x)
		{
			x = MARGIN;
			y += (maxAscent + maxDescent + MARGIN);
		}

		// calculate texture coordinates of the character
		texX1 = static_cast<float>(x) / imageWidth;
		texX2 = static_cast<float>(x+widths_[ch]) / imageWidth;
		texY1 = static_cast<float>(y - maxAscent) / imageHeight;
		texY2 = texY1 + static_cast<float>(height_) / imageHeight;

		// generate the character's display list
		glNewList(listBase_ + ch, GL_COMPILE);
		glBegin(GL_QUADS);
		glTexCoord2f(texX1,texY1);  glVertex2i(0,0);
		glTexCoord2f(texX2,texY1);  glVertex2i(widths_[ch],0);
		glTexCoord2f(texX2,texY2);  glVertex2i(widths_[ch],height_);
		glTexCoord2f(texX1,texY2);  glVertex2i(0,height_);
		glEnd();
		glTranslatef(widths_[ch],0,0);  // translate forward
		glEndList();

		// copy image generated by FreeType to the texture
		for(int row = 0; row < face->glyph->bitmap.rows; ++row)
		{
			for(int pixel = 0; pixel < face->glyph->bitmap.width; ++pixel)
			{
				int ind = (x + face->glyph->bitmap_left + pixel) +
					(y - face->glyph->bitmap_top + row) * imageWidth;
				// set pixel at position to intensity (0-255) at the position
				image[ind] = face->glyph->bitmap.buffer[pixel + row * face->glyph->bitmap.pitch];
			}
		}

		x += widths_[ch];
	}

	// generate the OpenGL texture from the byte array
	glGenTextures(1, &texID_);
	glBindTexture(GL_TEXTURE_2D, texID_);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA8, imageWidth, imageHeight, 0,
		GL_ALPHA, GL_UNSIGNED_BYTE, image);

	delete[] image;		// now done with the image memory
	FT_Done_Face(face);	// free the face data

	if (!glIsTexture(texID_))
		throw std::logic_error("Invalid texture. Is something wrong with the font?");
}

void Font::release()
{
	if(glIsList(listBase_))
		glDeleteLists(listBase_, NUM_CHARS);

	if(glIsTexture(texID_))
		glDeleteTextures(1, &texID_);

	// clear out data
	texID_ = 0;
	listBase_ = 0;
	widths_.clear();
	widths_.resize(NUM_CHARS);
	height_ = 0;
}

void Font::drawText(float x, float y, const char *str, ...) const
{
	std::va_list args;
	va_start(args,str);
	char buf[1024];
	std::vsnprintf(buf, 1024, str, args);   // avoid buffer overflow
	va_end(args);

	glBindTexture(GL_TEXTURE_2D, texID_);
	glPushMatrix();
	glTranslated(x,y,0);
	for(unsigned int i=0; i < strlen(buf); ++i)
	{
		unsigned char ch( buf[i] - SPACE );	 // ch-SPACE = DisplayList offset
		// replace characters outside the valid range with undrawable
		if(ch > NUM_CHARS)
			ch = NUM_CHARS-1;   // last character is 'undrawable'

		glCallList(listBase_+ch);	// calculate list to call
	}
	glPopMatrix();
}

void Font::drawText(float x, float y, const std::string& str) const
{
	glBindTexture(GL_TEXTURE_2D, texID_);
	glPushMatrix();
	glTranslated(x,y,0);
	for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
	{
		unsigned char ch( *i - SPACE ); // ch-SPACE = DisplayList offset
		// replace characters outside the valid range with undrawable
		if(ch > NUM_CHARS)
		{
			ch = NUM_CHARS-1;   // last character is 'undrawable'
		}
		glCallList(listBase_+ch);	// calculate list to call
	}
	glPopMatrix();
}

std::ostream& Font::beginDraw(float x, float y)
{
	// clear the string and store the draw-position
	m_ss.str("");
	m_X = x;
	m_Y = y;
	return m_ss;
}

void Font::endDraw()
{
	drawText(m_X, m_Y, m_ss.str());	// draw the string
	m_ss.str("");				// clear the buffer
}

unsigned int Font::calcStringWidth(const std::string& str) const
{
	unsigned int width = 0;

	// iterate through widths of each char and accumulate width of string
	for(std::string::const_iterator i = str.begin(); i < str.end(); ++i)
		width += widths_[static_cast<unsigned int>(*i) - SPACE];

	return width;
}

unsigned int Font::getHeight() const
{
	return height_;
}
